### 当在浏览器输入url后 会经历如下过程
#### 1 url输入
输入网址后，首先会检查是否是合法的链接地址
  如果合法：看是否完整，对地址还会进行猜测，补全前缀或后缀
  不合法：将输入的内容作为搜索条件，使用默认的搜索引擎搜索
现在大部分浏览器会从历史记录/书签中查找我们输入的网址，给出智能提示
#### 2、DNS解析
浏览器通过DNS查找域名的IP地址
  浏览器缓存 – 浏览器会缓存DNS记录一段时间。 有趣的是，操作系统没有告诉浏览器储存DNS记录的时间，这样不同浏览器会储存个自固定的一个时间（2分钟到30分钟不等）。
  系统缓存 – 如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用（windows里是gethostbyname）。这样便可获得系统缓存中的记录。
  路由器缓存 – 接着，前面的查询请求发向路由器，它一般会有自己的DNS缓存。
  ISP DNS 缓存 – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。
  递归搜索 – 你的ISP的DNS服务器从跟域名服务器开始进行递归搜索。
当浏览器获取到服务器的IP后，会用一个随机的端口向服务器的80端口发起TCP请求

#### 3、浏览器与目标服务器建立TCP连接（3次握手） 建立连接。

### 4、浏览器通过http/https协议发送请求
  https会在TCP与http之间增加一层协议，作为加密及认证服务，https使用SSL和TLS,保障信息安全。
  SSL协议的作用，认证客户端与服务器，确保数据发送到正确的客户端与服务端，加密数据，防止数据中途被窃取。维护数据的完整性，保证数据在传输的过程中不被改变。    TLS协议的作用：用于两个通信应用程序之间，提供保密性与数据完整性，它由TLS记录协议与TLS握手协议组成


#### 5、服务器端响应请求
服务端向客户端发送请求结果

#### 6、浏览器渲染页面
浏览器解析html代码，并且构建DOM树。
处理CSS,构建CSSOM树.
将DOM树与CSSOM树合并成一个渲染数。
根据渲染数对页面进行布局绘制，计算每个节点的几何信息。
将各节点渲染到屏幕上，完成页面的渲染

#### 7、释放TCP连接（4次挥手）
渲染后就可以断开TCP连接了，但是正常琴情况下，为节省网络开销，会把请求头的Connection设置为keep-alive，保持持久化连接。当关闭页签时才释放TCP连接。
以上就是完整的过程。


### 扩展 TCP建立连接，三次握手
参考视频 https://www.bilibili.com/video/BV1V54y1y7c4/?p=4&spm_id_from=pageDriver&vd_source=135a0c294a680e326741144647de37f7 
就是建立一次TCP连接，客户端与服务端需要三个数据包，握手的主要作用就是确认双方【接收】与【发送】能力是否正常，初始序列号，交换窗口大小信息。
第一次握手：客户端发送 SYN 报文，序列号seq=x,并进入 SYN_SENT 状态，等待服务器确认。
第二次握手：服务器收到 SYN 报文后，需要向客户端发送 ACK 确认报文(x+1)，同时也发送 SYN 报文(y)。 所以向客户端发送 SYN + ACK 报文， 并进入 SYN_RCVD 状态。
第三次握手：客户端接受到 SYN + ACK 报文后，向服务端发送ACK (y+1)确认包。客户端进入 ESTABLISKED 状态。待服务器接受到客户端的确认包后，也进入 ESTABLISKED 状态。
  为啥要三次？2次不行？
    第一：2次握手，只能让客户端知道服务端的【接收】与【发送】能力正常，服务端知道客户端【发送】能力正常。
         如果没有第三次，服务端服务无法确认客户端【接收】能力是正常的。
        只有通过三次，才能让客户端与服务端确认双发的【接收】与【发送】能力都正常。
    第二：确认序列号可靠同步，如果是2次握手，服务端无法确认客户端收到自己的初始化序列号。
    第三：阻止重复历史连接的初始化，客户端由于某种原因发送2个不同序号的SYN包，我们知道网络环境是复杂的，旧的数据包可能先到服务器。服务器收到旧的SYN就会立即建立连接，造成网路异常。
    第四；安全问题，2次会放大DDOS攻击，为了保障数据的传输正确安全，又要提高传输效率。

### 扩展 TCP断开连接，四次挥手
第一次挥手：客户端发送 FIN 报文，并进入 FIN_WAIT_1 状态，消耗一个序号。
第二次挥手：服务器收到 FIN 报文后，需要向客户端发送 ACK 确认报文，同时带上自己的序号。 服务端进入 CLOSE_WAIT 状态，这时候客户端已经没有数据要发送了，
          但是服务端要发送的话，客户端依然要接受，客户端接收到 ACK 后， 进入 FIN_WAIT_2 状态。
第三次挥手：服务器端发送数据完毕后，向客户端发送 FIN 包，半连接状态下的服务器可能又发送了些数据，此时服务器处与 LAST_ACK状态
第四次握手：客户端接收到服务端的 FIN 包后，发出确认包 ACK. 此时客户端处于 TIME_AWAIT 状态。此时tcp连接还没有释放。必须经过两个MSL过后，才会进入CLOSE状态
          而服务器端收到客户端发送的ACK后，就进入CLOSE状态。可以看出服务器端结束tcp连接比客户单要早些。客户端要等待2MSL后close（防止客户端的ACK发送失败，和服务端还有数据要发送）
  为啥建立连接3次，而关闭连接是四次？
    在tcp握手的时候，接收端发送 SYN+ACK 是将两个包合并一个包发送的，所以减少一次包的发送。
    对于四次挥手，因为tcp是全双工通信，在主动关闭发送FIN包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道。所以不能将服务器端的FIN包与对客户端的ACK
    包合并发送，只能先确认ACK。然后等数据无需发送数据时，再发送FIN包。所以是四次挥手。


